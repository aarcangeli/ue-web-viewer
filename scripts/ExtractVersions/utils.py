import argparse
import io
import re
import subprocess
import sys
from functools import lru_cache
from pathlib import Path
from typing import NoReturn, List


def error(message: str) -> NoReturn:
    print(f"ERROR: {message}", file=sys.stderr)
    sys.exit(1)


def warning(message: str):
    print(f"WARNING: {message}", file=sys.stderr)


def parse_block(source: str, prefix: str):
    """
    Given a block of text, finds a block using the provided regex, and scans until the matching '}' is found.

    es: parse_block("struct FStruct { int32 Value; }", "struct FStruct") -> "{ int32 Value; }"
    """
    if match := re.search(prefix + r"\s*{", source, re.IGNORECASE):
        start = match.end()
        return follow_paren(source[start - 1 :])


def follow_paren(source: str) -> str:
    """Given a source string with a starting '{', return the string until the matching '}'"""

    assert source.startswith("{")

    level = 0
    for i, c in enumerate(source):
        if c == "{":
            level += 1
        elif c == "}":
            level -= 1
            if level == 0:
                return source[: i + 1]

    return source


def spawn_process(command: list[str], allow_error=False, print_errors=True):
    command = [str(x) for x in command]

    print(f"-- Running {' '.join(command)}")
    process = subprocess.run(
        command,
        stdout=subprocess.PIPE,
        stderr=None if print_errors else subprocess.PIPE,
        shell=True,
    )

    if process.returncode != 0 and not allow_error:
        error(f"process returned {process.returncode}")

    return process.stdout.decode("utf-8")


def compare_versions(a: str, b: str) -> int:
    left = [int(i) for i in a.split("-")[0].split(".")]
    right = [int(i) for i in b.split("-")[0].split(".")]
    if left < right:
        return -1
    if left > right:
        return 1
    return 0


def extract_tags(unreal_path: Path) -> list[str]:
    command = ["git", "-C", unreal_path, "tag"]

    tags = spawn_process(command).split("\n")

    # Use only release tags
    tags = [tag for tag in tags if tag.endswith("-release")]

    # Sort tags, because the default sort puts 4.10 before 4.2
    tags.sort(key=lambda x: [int(i) for i in x.split("-")[0].split(".")])

    return tags


def clean_tag_name(tag):
    return tag.replace("-release", "")


@lru_cache(maxsize=None)
def get_git_file(root: Path, filename: str | Path, revision: str = "HEAD"):
    path_unix = str(filename).replace("\\", "/")
    return spawn_process(
        ["git", "-C", root, "show", f"{revision}:{path_unix}"],
        allow_error=True,
        print_errors=False,
    )


def write_file(path: Path, content):
    print(f"Writing {path}")
    if not path.parent.exists():
        path.parent.mkdir(parents=True)
    # on windows, use \r\n
    with io.open(path, "w", encoding="utf-8", newline="\n") as f:
        f.write(content)


def read_file(path):
    with io.open(path, "r", encoding="utf-8") as f:
        return f.read()


def parse_global_args(description):
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument("unreal_engine_path", help="Path to Unreal Engine repository")
    args = parser.parse_args()

    return args


def make_header():
    import __main__

    filename = Path(__main__.__file__).name
    header = (
        f"// This file is generated by `{filename}`.\n"
        f"// Do not edit manually.\n"
        f"// noinspection JSUnusedGlobalSymbols\n"
        f"//\n"
    )
    return header


def ls_files(root: Path, tag: str) -> list[Path]:
    """Run git grep to find files matching the pattern in the specified tag."""
    # git ls-tree --name-only -r 5.6.0-release
    files = spawn_process(["git", "-C", root, "ls-tree", "--name-only", "-r", tag])
    return [Path(file.strip()) for file in files.strip().split("\n") if file]


def grep_files(root: Path, pattern: str, tag: str) -> list[Path]:
    """Run git grep to find files matching the pattern in the specified tag."""
    files = spawn_process(
        [
            "git",
            "-C",
            root,
            "grep",
            "--full-name",
            "--files-with-matches",
            pattern,
            tag,
        ]
    )
    return [
        Path(file.strip().split(":")[1]) for file in files.strip().split("\n") if file
    ]


@lru_cache(maxsize=None)
def get_files_by_name(root: Path, tag: str) -> dict[str, list[Path]]:
    file_by_name: dict[str, list[Path]] = {}

    # scan all files
    for file in ls_files(root, tag):
        # Index all files by name
        name = file.name.lower()
        if name not in file_by_name:
            file_by_name[name] = []
        file_by_name[name].append(file)

    return file_by_name


def get_full_name_from_filename(root: Path, file_name: str, tag: str) -> List[Path]:
    file_name = file_name.lower()

    file_by_name = get_files_by_name(root, tag)
    if file_name in file_by_name:
        return file_by_name[file_name]

    return []
