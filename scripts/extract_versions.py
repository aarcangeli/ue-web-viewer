import argparse
import re
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path

output_dir = Path(__file__).parent.parent / "src/unreal-engine"
""" Path where the output file will be saved """

path_versions = output_dir / "versions.ts"
path_version_details = output_dir / "version-details.ts"

regex_enum = r"\nenum(?: class)? __name__[^}]*};"
regex_enum_row = r"(?://\s*(.*))?\n\s+([\d\w]+)(?: *= *(\d+))?,"

path_version_file = "Engine/Source/Runtime/Core/Public/UObject/ObjectVersion.h"

# versions to ignore
ignored_versions = {
    "VER_UE4_OLDEST_LOADABLE_PACKAGE",
    "VER_UE4_MOVEMENTCOMPONENT_UPDATEDSCENECOMPONENT",
}

header = """
// This file is generated by `extract_versions.py`.
// Do not edit manually.
//
""".lstrip()

detail_struct = """
export interface VersionDetails {
  name: string;
  comment?: string;
  value: number;
  firstAppearance: string;
  lastAppearance: string;
}
""".lstrip()


@dataclass
class SerializationVersion:
    name: str
    value: int
    comment: str = None
    first_appearance: str = None
    last_appearance: str = None


def error(message: str, die=True):
    print(f"ERROR: {message}", file=sys.stderr)
    if die:
        sys.exit(1)


def spawn_process(command: list[str]):
    command = [str(x) for x in command]

    print(f"-- Running {' '.join(command)}")
    process = subprocess.run(command, stdout=subprocess.PIPE, shell=True)

    if process.returncode != 0:
        error(f"process returned {process.returncode}")

    return process.stdout.decode("utf-8")


def extract_tags(unreal_path: Path):
    command = ["git", "-C", unreal_path, "tag"]

    tags = spawn_process(command).split("\n")

    # Use only release tags
    tags = [tag for tag in tags if tag.endswith("-release")]

    # Sort tags, because the default sort puts 4.10 before 4.2
    tags.sort(key=lambda x: [int(i) for i in x.split("-")[0].split(".")])

    return tags


def extract_version_enums(enum_name: str, file: str):
    # find regex
    match = re.search(regex_enum.replace("__name__", enum_name), file)
    if not match:
        error(f"Enum {enum_name} not found")

    enum_ue4_version = match.group(0)
    rows = re.findall(regex_enum_row, enum_ue4_version)
    value = None

    result = []
    already_found = set()
    for row in rows:
        comment, field_name, field_value = row

        # Ignore last fields
        if "AUTOMATIC_VERSION" in field_name:
            continue

        # Find version constant
        if field_value:
            if value is not None:
                error(f"Found two rows with value: {value} and {field_value}")
            value = int(field_value)
        else:
            if value is None:
                error(f"The first row must have a version value, found {field_name}")
            value = value + 1

        # Skip oldest loadable version
        if field_name in ignored_versions:
            continue

        # Check unique field names
        if field_name in already_found:
            error(f"Field {field_name} already found")
        already_found.add(field_name)

        result.append((field_name, value, comment))

    return result


def format_versions(
    ue4_versions: list[SerializationVersion],
    ue5_versions: list[SerializationVersion],
):
    result = header
    result += "// This file contains all the versions used by Unreal Engine to serialize objects\n"
    result += "// The global version number is placed in the summary of all assets\n"
    result += "// See ObjectVersion.h for more information\n"
    result += "// noinspection JSUnusedGlobalSymbols\n\n"

    result += print_table("EUnrealEngineObjectUE4Version", ue4_versions)
    result += print_table("EUnrealEngineObjectUE5Version", ue5_versions)

    return result


def escape_string(s):
    return '"' + str(s).replace('"', '\\"') + '"'


def format_version_details(
    ue4_versions: list[SerializationVersion], ue5_versions: list[SerializationVersion]
):
    result = f"{header}\n{detail_struct}\n"

    result += "export const versionsDetails: VersionDetails[] = [\n"
    for version in ue4_versions + ue5_versions:
        result += "  {\n"
        result += f"    name: {escape_string(version.name)},\n"
        if version.comment:
            result += f"    comment: {escape_string(version.comment)},\n"
        result += f"    value: {version.value},\n"
        result += f"    firstAppearance: {escape_string(clean_tag_name(version.first_appearance))},\n"
        result += f"    lastAppearance: {escape_string(clean_tag_name(version.last_appearance))},\n"
        result += "  },\n"
    result += "];\n"

    return result


def clean_tag_name(tag):
    return tag.replace("-release", "")


def print_table(name, versions: list[SerializationVersion]):
    result = "export enum %s {\n" % name

    last_ue_version = None

    for version in versions:
        if last_ue_version != version.first_appearance:
            if last_ue_version:
                result += "  // endregion\n\n"
            result += f"  // region Introduced with UE {clean_tag_name(version.first_appearance)}\n"
            last_ue_version = version.first_appearance

        if version.comment:
            result += f"  /// {version.comment.strip()}\n"
        result += f"  {version.name} = {version.value},\n"
    result += "  // endregion\n"
    result += "}\n\n"

    return result


def validate_table(version_by_name_ue4: list[SerializationVersion]):
    seen_versions = set()

    for version in version_by_name_ue4:
        if version.value in seen_versions:
            error(f"WARNING: Version number {version.value} is duplicated", False)
        seen_versions.add(version.value)


def aggregate_versions(tag, versions, result_list: list[SerializationVersion]):
    for field_name, value, comment in versions:
        # Get the index of the version already stored in the list, if any
        found_index = next(
            (i for i, version in enumerate(result_list) if version.name == field_name),
            None,
        )

        if found_index is not None:
            if result_list[found_index].value != value:
                error(
                    f"Field {field_name} has different version number {value} != {result_list[found_index].value}"
                )

            # Latest version should have a better comment
            if comment:
                result_list[found_index].comment = comment

            result_list[found_index].last_appearance = tag

        else:
            result_list.append(
                SerializationVersion(field_name, value, comment, tag, tag)
            )


def write_file(path, content):
    print(f"Writing {path}")
    with open(path, "w", encoding="utf-8") as f:
        f.write(content)


def main():
    parser = argparse.ArgumentParser(
        description="Check all tags of UnrealEngine repository, and populate the tables of this directory"
    )
    parser.add_argument("unreal_engine_path", help="Path to Unreal Engine repository")
    parser.add_argument(
        "--prettify", action="store_true", help="Run prettier on the output files"
    )
    args = parser.parse_args()

    if not output_dir.exists():
        output_dir.mkdir(parents=True)

    unreal_path = Path(args.unreal_engine_path)
    if not unreal_path.exists():
        print(f"Path {unreal_path} does not exist")
    #         return

    version_by_name_ue4: list[SerializationVersion] = []
    version_by_name_ue5: list[SerializationVersion] = []

    tags = extract_tags(unreal_path)
    for tag in tags:
        # for tag in tags:
        print(f"Processing tag {tag}")

        file = spawn_process(
            ["git", "-C", unreal_path, "show", f"{tag}:{path_version_file}"]
        )

        # Extract UE4 versions
        ue4_versions = extract_version_enums("EUnrealEngineObjectUE4Version", file)
        aggregate_versions(tag, ue4_versions, version_by_name_ue4)

        # ue5 is optional
        if tag.startswith("5."):
            ue5_versions = extract_version_enums("EUnrealEngineObjectUE5Version", file)
            aggregate_versions(tag, ue5_versions, version_by_name_ue5)

    print("Validating tables")
    validate_table(version_by_name_ue4)
    validate_table(version_by_name_ue5)

    versions = format_versions(version_by_name_ue4, version_by_name_ue5)
    version_details = format_version_details(version_by_name_ue4, version_by_name_ue5)

    write_file(path_versions, versions)
    write_file(path_version_details, version_details)

    # Run prettier
    if args.prettify:
        print("Running prettier")
        spawn_process(["npx", "prettier", "--write", path_versions])
        spawn_process(["npx", "prettier", "--write", path_version_details])


if __name__ == "__main__":
    main()
